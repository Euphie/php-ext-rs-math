//! 高级数学运算模块
//! 
//! 这个模块包含更复杂的数学函数
//! 如三角函数、对数、统计函数等

use std::os::raw::c_double;

/// 计算平方根
/// 
/// # 参数
/// * `n` - 要计算平方根的数字
/// 
/// # 返回值
/// 平方根结果
pub fn sqrt(n: c_double) -> c_double {
    n.sqrt()
}

/// 计算立方根
/// 
/// # 参数
/// * `n` - 要计算立方根的数字
/// 
/// # 返回值
/// 立方根结果
pub fn cbrt(n: c_double) -> c_double {
    n.cbrt()
}

/// 计算自然对数
/// 
/// # 参数
/// * `n` - 要计算对数的数字
/// 
/// # 返回值
/// 自然对数结果，如果输入小于等于0则返回0.0
pub fn ln(n: c_double) -> c_double {
    if n <= 0.0 {
        0.0
    } else {
        n.ln()
    }
}

/// 计算常用对数（以10为底）
/// 
/// # 参数
/// * `n` - 要计算对数的数字
/// 
/// # 返回值
/// 常用对数结果，如果输入小于等于0则返回0.0
pub fn log10(n: c_double) -> c_double {
    if n <= 0.0 {
        0.0
    } else {
        n.log10()
    }
}

/// 计算正弦函数
/// 
/// # 参数
/// * `x` - 角度（弧度）
/// 
/// # 返回值
/// 正弦值
pub fn sin(x: c_double) -> c_double {
    x.sin()
}

/// 计算余弦函数
/// 
/// # 参数
/// * `x` - 角度（弧度）
/// 
/// # 返回值
/// 余弦值
pub fn cos(x: c_double) -> c_double {
    x.cos()
}

/// 计算正切函数
/// 
/// # 参数
/// * `x` - 角度（弧度）
/// 
/// # 返回值
/// 正切值
pub fn tan(x: c_double) -> c_double {
    x.tan()
}

/// 计算反正弦函数
/// 
/// # 参数
/// * `x` - 正弦值
/// 
/// # 返回值
/// 角度（弧度）
pub fn asin(x: c_double) -> c_double {
    x.asin()
}

/// 计算反余弦函数
/// 
/// # 参数
/// * `x` - 余弦值
/// 
/// # 返回值
/// 角度（弧度）
pub fn acos(x: c_double) -> c_double {
    x.acos()
}

/// 计算反正切函数
/// 
/// # 参数
/// * `x` - 正切值
/// 
/// # 返回值
/// 角度（弧度）
pub fn atan(x: c_double) -> c_double {
    x.atan()
}

/// 计算双曲正弦函数
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 双曲正弦值
pub fn sinh(x: c_double) -> c_double {
    x.sinh()
}

/// 计算双曲余弦函数
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 双曲余弦值
pub fn cosh(x: c_double) -> c_double {
    x.cosh()
}

/// 计算双曲正切函数
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 双曲正切值
pub fn tanh(x: c_double) -> c_double {
    x.tanh()
}

/// 计算伽马函数（近似）
/// 
/// 使用斯特林公式近似计算伽马函数
/// 
/// # 参数
/// * `n` - 输入值
/// 
/// # 返回值
/// 伽马函数值
pub fn gamma(n: c_double) -> c_double {
    if n <= 0.0 {
        return 0.0;
    }
    
    // 使用斯特林公式近似
    let x = n - 1.0;
    let result = (2.0 * std::f64::consts::PI * x).sqrt() * 
                 (x / std::f64::consts::E).powf(x) * 
                 (1.0 + 1.0 / (12.0 * x) + 1.0 / (288.0 * x * x));
    
    result
}

/// 计算贝塞尔函数 J0（零阶第一类贝塞尔函数）
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 贝塞尔函数值
pub fn bessel_j0(x: c_double) -> c_double {
    // 简单的近似实现
    if x.abs() < 3.75 {
        let y = (x / 3.75) * (x / 3.75);
        1.0 + y * (3.5156229 + y * (3.0899424 + y * (1.2067492 + y * (0.2659732 + y * (0.0360768 + y * 0.0045813)))))
    } else {
        let z = 3.75 / x.abs();
        let result = 0.39894228 + z * (0.01328592 + z * (0.00225319 + z * (-0.00157565 + z * (0.00916281 + z * (-0.02057706 + z * (0.02635537 + z * (-0.01647633 + z * 0.00392377)))))));
        result * (x.abs().sqrt().recip()) * (x.abs() - 0.78539816).cos()
    }
}

/// 计算误差函数
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 误差函数值
pub fn erf(x: c_double) -> c_double {
    // 使用近似公式
    let a1 = 0.254829592;
    let a2 = -0.284496736;
    let a3 = 1.421413741;
    let a4 = -1.453152027;
    let a5 = 1.061405429;
    let p = 0.3275911;
    
    let sign = if x < 0.0 { -1.0 } else { 1.0 };
    let x = x.abs();
    
    let t = 1.0 / (1.0 + p * x);
    let y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * (-x * x).exp();
    
    sign * y
}

/// 计算补误差函数
/// 
/// # 参数
/// * `x` - 输入值
/// 
/// # 返回值
/// 补误差函数值
pub fn erfc(x: c_double) -> c_double {
    1.0 - erf(x)
} 